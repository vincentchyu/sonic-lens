package lastfm

import (
	"bufio"
	"context"
	"encoding/json/v2"
	"errors"
	"fmt"
	"os"
	"strings"
	"time"

	redisgo "github.com/redis/go-redis/v9"
	"github.com/shkh/lastfm-go/lastfm"
	"go.uber.org/zap"

	"github.com/vincentchyu/sonic-lens/common"
	"github.com/vincentchyu/sonic-lens/config"
	alog "github.com/vincentchyu/sonic-lens/core/log"
	coreredisclient "github.com/vincentchyu/sonic-lens/core/redis"
)

var (
	lastfmApi    = new(Api)
	_redisClient *redisgo.Client
)

type Api struct {
	*lastfm.Api
}

type (
	Struct2Map interface {
		ToMap() (res map[string]interface{}, err error)
	}
	base struct {
		ApiKey string `json:"api_key"` // A Last.fm API key.
		ApiSig string `json:"api_sig"` //  A Last.fm method signature. See authentication for more information.
		Sk     string `json:"sk"`      //  A session key generated by authenticating a user via the authentication protocol.
	}

	PushTrackScrobbleReq struct {
		base
		Artist             string `json:"artist"`               // The artist name.
		AlbumArtist        string `json:"albumArtist,optional"` // The album artist - if this differs from the track artist.
		Track              string `json:"track"`                // The track name.
		Album              string `json:"album"`                // Sub-client version (not public, only enabled for certain API keys)
		TrackNumber        int64  `json:"trackNumber,optional"` // The track number of the track on the album.
		Timestamp          int64  `json:"timestamp"`            // The time the track started playing, in UNIX timestamp format (integer number of seconds since 00:00:00, January 1st 1970 UTC). This must be in the UTC time zone.
		MusicBrainzTrackID string `json:"mbid,optional"`        // The MusicBrainz Track ID.
		Context            string `json:"context,optional"`     // Sub-client version (not public, only enabled for certain API keys)
		StreamId           int64  `json:"streamId,optional"`    // The stream id for this track received from the radio.getPlaylist service, if scrobbling Last.fm radio
		Duration           int64  `json:"duration,optional"`    // The length of the track in seconds.
		ChosenByUser       int64  `json:"chosenByUser,optional"`
		Sk                 string `json:"sk"` // A session key generated by authenticating a user via the authentication protocol.
	}
	TrackUpdateNowPlayingReq struct {
		base
		Artist             string `json:"artist"`               // The artist name.
		AlbumArtist        string `json:"albumArtist,optional"` // The album artist - if this differs from the track artist.
		Track              string `json:"track"`                // The track name.
		Album              string `json:"album,optional"`       // Sub-client version (not public, only enabled for certain API keys)
		TrackNumber        int64  `json:"trackNumber,optional"` // The track number of the track on the album.
		MusicBrainzTrackID string `json:"mbid,optional"`        // The MusicBrainz Track ID.
		Context            string `json:"context,optional"`     // Sub-client version (not public, only enabled for certain API keys)
		Duration           int64  `json:"duration,optional"`    // The length of the track in seconds.
	}
	TrackGetInfoReq struct {
		base
		// "artist", "track", "mbid", "username", "autocorrect"
		Artist string `json:"artist"` // The artist name.
		Track  string `json:"track"`  // The track name.
		// Album              string `json:"album"`         // album
		MusicBrainzTrackID string `json:"mbid,optional"` // The MusicBrainz Track ID.
		Username           string `json:"username"`      // username
	}
	TrackUpdateNowPlayingResp struct {
		XMLName XMLName `json:"XMLName"`
		Track   struct {
			Corrected string `json:"Corrected"`
			Name      string `json:"Title"`
		} `json:"Track"`
		Artist struct {
			Corrected string `json:"Corrected"`
			Name      string `json:"Title"`
		} `json:"Artist"`
		Album struct {
			Corrected string `json:"Corrected"`
			Name      string `json:"Title"`
		} `json:"Album"`
		AlbumArtist struct {
			Corrected string `json:"Corrected"`
			Name      string `json:"Title"`
		} `json:"AlbumArtist"`
		IgnoredMessage struct {
			Corrected string `json:"Corrected"`
			Body      string `json:"Body"`
		} `json:"IgnoredMessage"`
	}
	GetLovedTracksResp struct {
		XMLName    XMLName `json:"XMLName"`
		User       string  `json:"User"`
		Total      int     `json:"Total"`
		Page       int     `json:"Page"`
		PerPage    int     `json:"PerPage"`
		TotalPages int     `json:"TotalPages"`
		Tracks     []Track `json:"Tracks"`
	}
	XMLName struct {
		Space string `json:"Space"`
		Local string `json:"Local"`
	}
	Date struct {
		Uts  string `json:"Uts"`
		Date string `json:"Date"`
	}
	Track struct {
		Name       string     `json:"Title"`
		Mbid       string     `json:"Mbid"`
		Url        string     `json:"Url"`
		Date       Date       `json:"Date"`
		Artist     Artist     `json:"Artist"`
		Images     []Images   `json:"Images"`
		Streamable Streamable `json:"Streamable"`
	}
	Artist struct {
		Name string `json:"Title"`
		Mbid string `json:"Mbid"`
		Url  string `json:"Url"`
	}
	Images struct {
		Size string `json:"Size"`
		Url  string `json:"Url"`
	}
	Streamable struct {
		FullTrack  string `json:"FullTrack"`
		Streamable string `json:"Streamable"`
	}
)

func init() {
}

func InitLastfmApi(
	ctx context.Context, apiKey, apiSecret, userLoginToken string, isMobile bool, userUsername, userPassword string,
) {
	_redisClient = coreredisclient.GetRedisClient()
	lastfmApi.Api = lastfm.New(apiKey, apiSecret)
	if isMobile {
		err := lastfmApi.Login(userUsername, userPassword)
		if err != nil {
			panic(err)
		}
	} else if len(userLoginToken) <= 0 {
		token, err := lastfmApi.GetToken()
		if err != nil {
			panic(err)
		}
		authUrl := lastfmApi.GetAuthTokenUrl(token)

		alog.Info(ctx, token)
		ok := promptUser(authUrl)
		if ok {
			err = lastfmApi.LoginWithToken(token)
			if err != nil {
				panic(err)
			}
		} else {
			panic("登陆失败")
		}
	} else {
		err := lastfmApi.LoginWithToken(userLoginToken)
		if err != nil {
			panic(err)
		}
	}
}

func promptUser(url string) bool {
	fmt.Println("请在浏览器中打开以下URL，并完成验证码验证:")
	fmt.Println(url)
	reader := bufio.NewReader(os.Stdin)
	fmt.Print("验证完成请输入【ok】完成验证，键入回车: ")
	text, _ := reader.ReadString('\n')
	text = removeNewlines(text)
	return strings.TrimSpace(text) == "ok"
}

func removeNewlines(s string) string {
	return strings.ReplaceAll(s, "\n", "")
}

func (t *PushTrackScrobbleReq) ToMap() (res map[string]interface{}, err error) {
	res = make(map[string]any)
	err = common.Decode(t, &res)
	if err != nil {
		return nil, err
	}
	return res, err
}

func (t *TrackUpdateNowPlayingReq) ToMap() (res map[string]interface{}, err error) {
	res = make(map[string]any)
	err = common.Decode(t, &res)
	if err != nil {
		return nil, err
	}
	return res, err
}

func (t *TrackGetInfoReq) ToMap() (res map[string]interface{}, err error) {
	res = make(map[string]any)
	err = common.Decode(t, &res)
	if err != nil {
		return nil, err
	}
	return res, err
}

/*
1.数据源服务：

	定时copy audirvana sqllite数据库 备份到mysql

2.采集上报lastfm服务：

	从mysql中取出最近播放列表
	检查是否标记LOVE
	检查是否标记跳过
	检查播放时长是否大于50%
	上报数据

3.采集用户lastfm top数据

	top album
	top track
	top artist
*/

func GetLovedTracksUser(user string, limit int) (result *GetLovedTracksResp, err error) {
	resp, err := lastfmApi.User.GetLovedTracks(
		map[string]interface{}{
			"user":  "vincentch1n",
			"limit": "10",
		},
	)
	if err != nil {
		return nil, err
	}
	marshal, err := json.Marshal(resp)
	if err != nil {
		return nil, err
	}
	result = new(GetLovedTracksResp)
	err = json.Unmarshal(marshal, result)
	if err != nil {
		return nil, err
	}
	return result, err
}

func PushTrackScrobble(ctx context.Context, req *PushTrackScrobbleReq) (string, error) {
	alog.Info(ctx, "PushTrackScrobble:", zap.Any("req", req))

	// 检查API是否已初始化
	if lastfmApi == nil || lastfmApi.Api == nil {
		alog.Warn(ctx, "Last.fm API not initialized")
		return "", fmt.Errorf("last.fm api not initialized")
	}

	reqMap, err := req.ToMap()
	if err != nil {
		alog.Warn(ctx, "TrackUpdateNowPlaying", zap.Error(err))
		return "", err
	}
	result, err := lastfmApi.Track.Scrobble(reqMap)
	if err != nil {
		alog.Warn(ctx, "TrackUpdateNowPlaying", zap.Error(err))
		return "", err
	}

	marshal, err := json.Marshal(result)
	if err != nil {
		alog.Warn(ctx, "TrackUpdateNowPlaying", zap.Error(err))
		return "", err
	}
	return string(marshal), nil
}

func TrackUpdateNowPlaying(ctx context.Context, req *TrackUpdateNowPlayingReq) error {
	alog.Info(ctx, "TrackUpdateNowPlaying", zap.Any("req", req))

	// 检查API是否已初始化
	if lastfmApi == nil || lastfmApi.Api == nil {
		alog.Warn(ctx, "Last.fm API not initialized")
		return fmt.Errorf("last.fm api not initialized")
	}

	resp := new(TrackUpdateNowPlayingResp)
	argsMap, err := req.ToMap()
	if err != nil {
		return err
	}
	result, err := lastfmApi.Track.UpdateNowPlaying(argsMap)
	if err != nil {
		alog.Warn(ctx, "TrackUpdateNowPlaying", zap.Error(err))
		return err
	}

	marshal, err := json.Marshal(result)
	if err != nil {
		alog.Warn(ctx, "TrackUpdateNowPlaying", zap.Error(err))
		return err
	}
	err = json.Unmarshal(marshal, resp)
	if err != nil {
		alog.Warn(ctx, "TrackUpdateNowPlaying", zap.Error(err))
		return err
	}

	// alog.Info(ctx, resp)
	return nil
}

// IsFavorite checks if the track is loved/favorited in Last.fm
func IsFavorite(ctx context.Context, artist, track string) (bool, error) {
	alog.Info(ctx, "Checking if track is loved", zap.String("artist", artist), zap.String("track", track))

	// Generate Redis key
	redisKey := fmt.Sprintf("cache:isFavorite:lastfm:%s:%s", artist, track)
	// 如果一直都没有被点赞每秒都会一直被调用，是不是可以用redis去设置缓存大概4分钟，这样每秒的播放如果一直没有被喜欢可以等他自己过期
	// 如果过程中调用SetFavorite，可以删除这个缓存，之后也可以从读取到
	// reids使用的key参考样例 cache:isFavorite:lastfm:{artist}:{track}
	// redis使用github.com/redis/go-redis. go-redis,在core抽象redis包包含初始化 client的、初始化、创建
	// reids相关的配置在config中加入
	// Try to get value from Redis cache first
	if val, err := _redisClient.Get(ctx, redisKey).Result(); err == nil {
		// Cache hit
		isLoved := val == "true"
		alog.Info(ctx, "Track loved status (from cache)", zap.Bool("isLoved", isLoved))
		return isLoved, nil
	} else if !errors.Is(err, redisgo.Nil) {
		// Redis error (not a cache miss)
		alog.Info(ctx, "Redis error when getting cached favorite status", zap.Error(err))
	}

	// 检查API是否已初始化
	if lastfmApi == nil || lastfmApi.Api == nil {
		alog.Warn(ctx, "Last.fm API not initialized")
		return false, fmt.Errorf("last.fm api not initialized")
	}
	req := TrackGetInfoReq{
		Artist:   artist,
		Track:    track,
		Username: config.ConfigObj.Lastfm.UserUsername,
	}
	// 调用Last.fm API获取歌曲信息
	res, err := req.ToMap()
	if err != nil {
		alog.Warn(ctx, "IsFavorite", zap.Error(err))
		return false, err
	}
	result, err := lastfmApi.Track.GetInfo(
		res,
	)
	if err != nil {
		alog.Warn(ctx, "Failed to get track info", zap.Error(err))
		return false, err
	}

	// UserLoved字段为"1"表示已收藏，"0"表示未收藏
	isLoved := result.UserLoved == "1"
	alog.Info(ctx, "Track loved status", zap.Bool("isLoved", isLoved))

	// Cache the result in Redis for 4 minutes
	{
		cacheValue := "false"
		if isLoved {
			cacheValue = "true"
		}
		// Set cache with 4-minute expiration
		if err := _redisClient.Set(ctx, redisKey, cacheValue, 4*time.Minute).Err(); err != nil {
			alog.Warn(ctx, "Failed to cache favorite status", zap.Error(err))
		}
	}

	return isLoved, nil
}

// SetFavorite sets the loved/favorited status of the track in Last.fm
func SetFavorite(ctx context.Context, artist, track string, favorited bool) error {
	alog.Info(
		ctx, "Setting track loved status", zap.String("artist", artist), zap.String("track", track),
		zap.Bool("favorited", favorited),
	)

	// 检查API是否已初始化
	if lastfmApi == nil || lastfmApi.Api == nil {
		alog.Warn(ctx, "Last.fm API not initialized")
		return fmt.Errorf("last.fm api not initialized")
	}

	var err error
	if favorited {
		// 收藏歌曲
		err = lastfmApi.Track.Love(
			map[string]interface{}{
				"artist": artist,
				"track":  track,
			},
		)
		if err != nil {
			alog.Warn(ctx, "Failed to love track", zap.Error(err))
			return err
		}
		alog.Info(ctx, "Track loved successfully")
	} else {
		// 取消收藏歌曲
		err = lastfmApi.Track.UnLove(
			map[string]interface{}{
				"artist": artist,
				"track":  track,
			},
		)
		if err != nil {
			alog.Warn(ctx, "Failed to unlove track", zap.Error(err))
			return err
		}
		alog.Info(ctx, "Track unloved successfully")
	}

	// Delete cache entry for this track
	{
		redisKey := fmt.Sprintf("cache:isFavorite:lastfm:%s:%s", artist, track)
		if err := _redisClient.Del(ctx, redisKey).Err(); err != nil {
			alog.Warn(ctx, "Failed to delete cached favorite status", zap.Error(err))
		}
	}

	return nil
}
